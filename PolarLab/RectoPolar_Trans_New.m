function Y=RectoPolar_Trans_New(X)%=====================================================================% This function performs a Recto (Pseudo) Polar transform on a 2D signal X given on a % Cartesian grid. If X is N*N, the output will have 2N by 2N output values. The algorithm% applied here uses the Fast Fractional Fourier Transfrom. The transform is applied in two% pairs of quadrants 1&3 and then 2&4, as in the drawing:%%                                                           \              /%                                                             \    1    /%                                                               \      /%                                                                 \  /%                                                            4     x    2%                                                                 /  \%                                                               /      \%                                                             /   3     \%                                                           /              \%   % Synopsis: Y=RectoPolar_Trans_New(X)%% Inputs -    X      N*N matrix in cartesian grid, (n is assumed to be even)              % Outputs - Y      2N*2N matrix (theta,r)%% Examples:%       N=64; X=zeros(N,N); X(N/4:3*N/4,N/4:3*N/4)=1;%       tic; Y_fast=RectoPolar_Trans_New(X); toc;%       [XC,YC]=Create_Grid('D',[N,pi],'.r');%       tic; Y_slow=Brute_Force_Transform(X,XC,YC); toc;%       figure(1); clf;%       subplot(2,2,1); imagesc(real(Y_fast)); xlabel('Fast - real part');%       subplot(2,2,2); imagesc(imag(Y_fast)); xlabel('Fast - imaginary part');%       subplot(2,2,3); imagesc(real(Y_slow)); xlabel('Slow - real part');%       subplot(2,2,4); imagesc(imag(Y_slow)); xlabel('Slow - imaginary part');%       disp(['Error between fast and slow: ',num2str(max(abs(Y_fast(:)-Y_slow(:))))]);%% Written on March 20th, 2005 by Michael Elad.%========================================================================%-------------------------------------------------------------------------------------------------------------------% Stage 1: Checking input size and defining the sizes of the input/output arrays%-------------------------------------------------------------------------------------------------------------------[N,m2]=size(X); if N~=m2,    disp('Non Square input array');    return;elseif floor(N/2)-N/2~=0,    disp('Size of the input array is not an integer nul. by 2');    return;end;Y=zeros(2*N,2*N); % The output array%-------------------------------------------------------------------------------------------------------------------% Stage 2: Constructing quadrant 1 and 3%-------------------------------------------------------------------------------------------------------------------f_tilde=fft([X; zeros(N,N)],[],1);f_tilde=fftshift(f_tilde,1); for ll=-N:1:N-1,     Y(ll+N+1,N:-1:1)=My_FRFT_Centered(f_tilde(ll+N+1,:),ll/N^2).';end;%-----------------------------------------------------------------------------------------------------% Stage 3: Constructing quadrant 2 and 4%-----------------------------------------------------------------------------------------------------f_tilde=fft([X, zeros(N,N)],[],2); f_tilde=fftshift(f_tilde,2);f_tilde=f_tilde.';for ll=-N:1:N-1,     Factor=exp(i*2*pi*(0:1:N-1)*(N/2-1)*ll/N^2);     Y(ll+N+1,N+1:2*N)=My_FRFT(f_tilde(ll+N+1,:).*Factor,ll/N^2).';end;return;