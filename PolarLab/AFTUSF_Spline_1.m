function F = AFTUSF_Spline_1(f,Wx,Wy,OS)%====================================================================% FTUSF_Spline: Approximate Fourier Transform at Unequally Spaced Frequencies.% The trigonometric polynomial %            F(omegax,omegay) = sum f(i,j) exp( -i (wx*x + wy*y))% is approximated for all the frequencies in (Wx,Wy) - any grid setup. The values of % this destination grid must be in the range [0,2pi]%  % Synopsis:    F = AFTUSF_NGP(f,Wx,Wy,OS)%  % Inputs:       f		 n*n array%	                 Wx		array of x-coordinates of frequencies%	                 Wy		array of y-coordinates of frequencies%	                 OS		Oversampling factor (dyadic, >= 1). Default 4.%%  Outputs:   F        Approximate Fourier Transform at frequencies in (Wx,Wy)%		                       Array conforming to shape of Wx.%  %  Example1 - The effect of oversampling oin the accuracy for Polar coordinates% %       Nr=16; Nt=32; %       [XP,YP]=Create_Grid('P',[Nr,Nt,pi],''); %       In=zeros(16,16); In(4:14,7:11)=1;%       Out1=Brute_Force_Transform(In,XP,YP);%       for OS=1:1:16, %           Out3=AFTUSF_NGP_1(In,XP,YP,OS); %           Out4=AFTUSF_Spline_1(In,XP,YP,OS); %           fprintf('%i  %e   %e \n',OS,mean(mean(abs(Out1-Out3))),...%                                 mean(mean(abs(Out1-Out4)))); %           figure(1); clf; %           [Wx,Wy]=Create_Grid('C',[16*OS,16*OS,-pi,pi,-pi,pi],'go'); hold on;%           plot(XP,YP,'r.'); %           pause;%       end;%       xlabel('Red - destination grid, Green - computed grid');% % Example 2 - how dense cartezian grid is approx. by a sparser cartezian grid% %       [Wxx,Wyy] = Create_Grid('C',[64,64,-pi,pi,-pi,pi],''); % destination grid%       f   = zeros(4,4); f(1,2) = 1; % given 4*4 signal%       Ff = Brute_Force_Transform(f,Wxx,Wyy);%       for OS=1:1:16,%           F1 = AFTUSF_NGP_1(f,Wxx,Wyy,OS);%           F2 = AFTUSF_Spline_1(f,Wxx,Wyy,OS);%           D1 = F1 - Ff;%           D2 = F2 - Ff;%           fprintf('%i  %e   %e \n',OS,mean(mean(abs(D1))),...%                       mean(mean(abs(D2)))); %       end;%% Written by Dave Donoho, and rearranged with slight change by Miki Elad % on March 20th, 2005.% % Copyright (c) David Donoho 2000%====================================================================if nargin < 3, 	OS = 4; endn =size(f,1); 					% assumes f squareN=n*OS;Ef=EmbedInZeros(f,N,'corner');   % pads f out to extension by factor OSF1=zeros([N N 3]); % array holding the FFT and its X- and Y-derivativesFout=fft2(Ef);				  % computing the Fourier TransformF1(:,:,1)=Fout;mi=(-1* sqrt(-1));		   % computing the Fourier Transform derivativesdelta=2*pi/N;[X,Y]=meshgrid(0:delta:2*pi-delta,0:delta:2*pi-delta);Fout=fft2(Ef .* mi .* X);   % Partial derivative of F in x-directionF1(:,:,2)=Fout;Fout=fft2(Ef .* mi .* Y);	% Partial derivative of F in y-directionF1(:,:,3)=Fout;F=EvalMCQuartSpline(F1,Wx,Wy);return;%===================================================function I = EmbedInZeros(x,N,where)%---------------------------------------------------------------------------------------------% EmbedInZeros: Embed an array in a sea of zeros. A copy of the array x is % embedded into an n*n part of a larger N*N array I.  The additional elements % are taken to be zero. The position of the window is either the central part, % an n*n window near N/2, or an n*n window bounded by (1,1) -> (n,n). %  % Synopsis: I = EmbedInZeros(x,N,where)%  % Inputs:    x		      array(n,n); n < N, data to embed%	               N		    integer; size of array into which to embed%	               where	string; 'center' / 'corner'%  Outputs: I	         array(N,N)%% Copyright (c) David Donoho 2000%---------------------------------------------------------------------------------------------if nargin < 3,    where = 'center';end%n = size(x,1);I = zeros(N);switch where,case 'center',    lo = floor(N/2) - (floor(n/2)-1);    hi = lo + n -1;case 'corner',    lo = 1;    hi = n;endI(lo:hi,lo:hi) = x; %===================================================function Y = EvalMCQuartSpline(F,xPoints,yPoints)%---------------------------------------------------------------------------------------------% EvalMCQuadSpline: Evaluate Marginally Cubic Quartic Spline at Scattered Points. % At each point of an N*N grid the values of a function polynomial, its partial in x, % and its partial in y, are given by the array F. The grid points are assumed to be % at points (2*pi*(k1-1)/N,2*pi*(k2-1)/N). The function is assumed to be 2-pi % periodic in each variable. A set of points for evaluation is given by % (xPoints,yPoints).%% Synopsis: Y = EvalMCQuartSpline(F,xPoints,yPoints)% % Inputs:     F		       (N,N,3) Stack of N*N complex matrices	%	                xPoints	x coordinates of Points to Evaluate Local Quartic Polynomial%	                yPoints y coordinates of Points to Evaluate Local Quartic Polynomial%  Outputs:  Y		     Value of Local Quartic, Marginally Cubic Polynomial at specified Points %	% Copyright (c) David Donoho 2000%---------------------------------------------------------------------------------------------M = MakeMCQuartSplineGen;Npts = prod(size(xPoints));N = size(F,1);Y = zeros(size(xPoints));xPoints = (xPoints>=0).*xPoints+(xPoints<0).*(xPoints+2*pi);yPoints = (yPoints>=0).*yPoints+(yPoints<0).*(yPoints+2*pi);x = xPoints*N/(2*pi);y = yPoints.*N/(2*pi);    for pt = 1:Npts,    [k2,k1,u1,u2] = FindCell(x(pt),y(pt),N);  % note k1 <--> k2 swap, u2 <--> u1 swap    if k1 < N & k2 < N,        g = PackGridVals(F(k1:(k1+1),k2:(k2+1),:));    elseif k1 < N,  % Periodization        bot = k2; top = k2+1;        if bot > N, bot = bot-N; end        if top > N, top = top-N; end        g = PackGridVals(F(k1:(k1+1),[bot top],:));    elseif k2 < N,        bot = k1; top = k1+1;        if bot > N, bot = bot-N; end        if top > N, top = top-N; end        g = PackGridVals(F([bot top],k2:(k2+1),:));    else        xbot = k1; xtop = k1+1;        if xbot > N, xbot = xbot-N; end        if xtop > N, xtop = xtop-N; end        ybot = k2; ytop = k2+1;        if ybot > N, ybot = ybot-N; end        if ytop > N, ytop = ytop-N; end        g = PackGridVals(F([xbot xtop],[ybot ytop],:));    end		    E = MakeMCQuartSplineEval(u1,u2);    v = E*M*g;    Y(pt) = v;end%===================================================function Minv = MakeMCQuartSplineGen%---------------------------------------------------------------------------------------------% MakeMCQuartSplineGen: Make Generator of Marginally Cubic Quartic Spline % Interpolation.  The quartic cubic polynomial pi has 15 coefficients, omitting % terms with x^4 and y^4. This can be determined by the 12 data given at the % vertices of the unit square by point values, and first partial derivatives. The % pseudo-inverse of matrix M, applied to the vector of these point values and % derivatives, gives the polynomial.%  % Synopsis: Minv = MakeMCQuadSplineGen%%  Outputs: Minv	matrix relating values of Cubic Spline to coefficients %	% Copyright (c) David Donoho 2000%---------------------------------------------------------------------------------------------iarray = [ 0 1 2 3 1  2 1 0 0 0  1 3 ];jarray = [ 0 0 0 0 1  1 2 1 2 3  3 1 ];i1array = [ NaN   0   1   2  0  1 0 NaN NaN NaN 0 2 ];j1array = [ NaN NaN NaN NaN  0  0 1   0   1   2 2 0 ];M = zeros(12,12);nrow = 0;for p=0:1,    for q = 0:1,        g  = (p.^iarray)  .* (q.^jarray) ;        gx = (p.^i1array) .* (q.^jarray)  .*iarray;        gy = (p.^iarray)  .* (q.^j1array) .*jarray;        gx(isnan(gx)) = zeros(1,sum(isnan(gx)));        gy(isnan(gy)) = zeros(1,sum(isnan(gy)));        M(nrow+1,:) = g ;        M(nrow+2,:) = gx;        M(nrow+3,:) = gy;        nrow = nrow+3;    endendMinv = inv(M);%===================================================function [k1,k2,u1,u2] = FindCell(x,y,n)%---------------------------------------------------------------------------------------------% FindCell: Locate Cell Index Corresponding to given (x,y) - An n*n array of unit % square cells, with lower left corner at (0,0) is assumed.  The index of the cell% containing (x,y) is returned, where the lower left cell is indexed by (1,1)%  % Synopsis: [k1,k2] = FindCell(x,y,n)%%  Inputs: 	  x	  	  x coordinate	%	                y		y coordinate%	                n		integer; size of n*n grid%  Outputs:  k1		integer x-index of cell in grid%	                k2		integer y-index of cell in grid%	                u1		fractional x-coordinate inside cell%	                u2		fractional y-coordinate inside cell%  %	Copyright (c) David Donoho 2000%---------------------------------------------------------------------------------------------k1 = 1 + floor(x);k2 = 1 + floor(y);u1 = x - floor(x);u2 = y - floor(y);%===================================================function g = PackGridVals(f);%---------------------------------------------------------------------------------------------% MakeMCQuadSplineGen: Make Generator of Marginally Cubic Quadratic Spline % Interpolation. Prepares vector of 12 values for use in conjunction with fitting % and using EvalMCQuadSpline.%  % Synopsis: g = PackGridVals(f)%  Inputs:      f	3-way array 2*2*3%  Outputs:   g	  vector 12*1  %% Copyright (c) 2000 -- David L. Donoho%---------------------------------------------------------------------------------------------g = zeros(12,1);nrow = 0;for p = 1:2,    for q = 1:2,        g(nrow+1) = f(q,p,1);        g(nrow+2) = f(q,p,2);        g(nrow+3) = f(q,p,3);        nrow = nrow+3;    endend%===================================================function E = MakeMCQuartSplineEval(x,y)%---------------------------------------------------------------------------------------------% MakeMCQuartSplineEval: Make Evaluator of Marginally Cubic Quadratic Spline % Interpolation. The marginally cubic quadratic cubic polynomial pi has 15 % coefficients, omitting terms with x^4 and y^4.  This can be determined by the % 12 data given at the vertices of the unit square by point values, and first partial % derivatives. The pseudo-inverse of matrix M, applied to the vector of these point% values and derivatives, gives the polynomial. %% Synopsis: E = MakeMCQuartSplineEval%  % Inputs:   x,y    the coordinates to evaluate the function in in the range [0,1]^2% Outputs: E	  Vector relating values of Cubic Spline at (x,y) to coefficients %%	Copyright (c) David Donoho 2000%---------------------------------------------------------------------------------------------iarray = [ 0 1 2 3 1  2 1 0 0 0  1 3 ];jarray = [ 0 0 0 0 1  1 2 1 2 3  3 1 ];E  = (x.^iarray)  .* (y.^jarray) ;