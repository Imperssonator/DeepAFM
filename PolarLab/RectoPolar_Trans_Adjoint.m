function Y=RectoPolar_Trans_Adjoint(X,Method)%====================================================================% This function performs a Recto (Pseudo) Polar ADJOINT transform on a 2D signal X % given on the PP-coordinate system. If X is 2N*2N, the output will have N by N values. % The algorithm applied here uses the Fast Fractional Fourier Transform. This program % proposes a set of algorithms (evolution) from the direct approach to the fastest % approach. %   % Synopsis: Y=RectoPolar_Trans_Adjoint(X,Method)%% Inputs -  X - 2N*2N matrix in pseudo-polar grid, (N is assumed to be even)%               Method - various methods to apply the transform (default - 8)%                  1. Creating the PP-FFT matrix, taking adjoint and applying on the input%                  2. Using the definition of the summation%                  3. Using the definition of the summation and reording summations%                  4. Applying FRFFT for the inner summation.%                  5. Speeded by preparing to replace the outer (L-wise) sum - step 1%                  6. Speeded by preparing to replace the outer (L-wise) sum - step 2%                  7. FFT in the outer summation and FRFFT in the inner one%                  8 . as in 7 but the FFT is done as 2D operation without loop.%               % Outputs - Y      N*N matrix (Cartesian grid)%% Examples: % %   The following establishes that all the methods do the same:%   X=randn(64,64); % the largest possible size for the dumb methods%   tic; Y1=RectoPolar_Trans_Adjoint(X,1); disp(['Method 1 elapsed time: ',num2str(toc)]); %   tic; Y2=RectoPolar_Trans_Adjoint(X,2); disp(['Method 2 elapsed time: ',num2str(toc)]); %   tic; Y3=RectoPolar_Trans_Adjoint(X,3); disp(['Method 3 elapsed time: ',num2str(toc)]); %   tic; Y4=RectoPolar_Trans_Adjoint(X,4); disp(['Method 4 elapsed time: ',num2str(toc)]); %   tic; Y5=RectoPolar_Trans_Adjoint(X,5); disp(['Method 5 elapsed time: ',num2str(toc)]); %   tic; Y6=RectoPolar_Trans_Adjoint(X,6); disp(['Method 6 elapsed time: ',num2str(toc)]); %   tic; Y7=RectoPolar_Trans_Adjoint(X,7); disp(['Method 7 elapsed time: ',num2str(toc)]); %   tic; Y8=RectoPolar_Trans_Adjoint(X,8); disp(['Method 8 elapsed time: ',num2str(toc)]); %   disp(['Error 1-2: ',num2str(norm(Y1-Y2))]);%   disp(['Error 1-3: ',num2str(norm(Y1-Y3))]);%   disp(['Error 1-4: ',num2str(norm(Y1-Y4))]);%   disp(['Error 1-5: ',num2str(norm(Y1-Y5))]);%   disp(['Error 1-6: ',num2str(norm(Y1-Y6))]);%   disp(['Error 1-7: ',num2str(norm(Y1-Y7))]);%   disp(['Error 1-8: ',num2str(norm(Y1-Y8))]);%%   The following establishes that it is indeed the adjoint of "Y=RectoPolar_Trans_New(X)":%   N=8; A=zeros(4*N^2,N^2); count=1;%   for k=1:1:N,% row lexicographic ordering in%       for j=1:1:N,%           X=zeros(N,N); X(k,j)=1;%           Y=RectoPolar_Trans_New(X);%           A(:,count)=Y(:); % column lexicographic out%           count=count+1;%       end;%   end;%   At=zeros(N^2,4*N^2); count=1;%   for k=1:1:2*N, % row lexicographic ordering in%       for j=1:1:2*N,%           X=zeros(2*N,2*N); X(k,j)=1;%           Y=RectoPolar_Trans_Adjoint(X,8);%           At(:,count)=Y(:); % column lexicographic ordering out%           count=count+1;%       end;%   end;%   disp(max(max(abs(At'-A))));% %   The following is another way - simpler - just to verify that it works as an adjoint%   N=16; X=randn(N,N); Y=randn(2*N,2*N);%   AX=RectoPolar_Trans_New(X);%   AX=AX.';%   AtY=RectoPolar_Trans_Adjoint(Y,8);%   AtY=AtY.';%   disp(abs( sum(sum(conj(Y).*AX)) - sum(sum(conj(X).*AtY))'  ));       %   Note the need to a transpose because of the different ordering in%   the in-out vectors in the adjoint definition.% % Written on March 20th, 2005 by Michael Elad.%=========================================+===========================% Default method is the fastestif nargin==1,     Method==8;end;% preliminary checks of the input size[N,m2]=size(X); if N~=m2,    disp('Non Square input array');    return;elseif floor(N/4)-N/4~=0,    disp('Size of the input array is not an integer mul. by 4');    return;end;N=N/2;if Method==1, % creating the transform matrix and applying the adjoint        Y=zeros(N,N);    [Xgrid,Ygrid]=Create_Grid('D',[N,pi],'');    TRR=Transform_Matrix(N,N,Xgrid,Ygrid);    TRR_adj=TRR'; % this is out adjoint matrix    Y=TRR_adj*reshape(X,[4*N^2,1]);    Y=reshape(Y,[N,N]);    elseif Method==2, % using the definition directly        Y=zeros(N,N);    for n=0:1:N-1,        for k=0:1:N-1,             Y(n+1,k+1)=0;            for l=-N:N-1,                for m=-N/2:N/2-1,                    Y(n+1,k+1)=Y(n+1,k+1)+X(N/2-m,l+N+1)*exp(i*(k*2*m/N+n)*pi*l/N);                end;            end;        end;    end;    for n=0:1:N-1,        for k=0:1:N-1,             for l=-N:N-1,                for m=-N/2+1:N/2,                    Y(n+1,k+1)=Y(n+1,k+1)+X(m+N/2+N,l+N+1)*exp(i*(n*2*m/N+k)*pi*l/N);                end;            end;        end;    end;    elseif Method==3, % using the definition but also the separability to reorder things        Y=zeros(N,N);    for n=0:1:N-1,        for l=-N:N-1,                           Factor=exp(i*n*pi*l/N);            m=-N/2:1:N/2-1;            Xvec=X(N:-1:1,l+N+1);            alpha=-l/N^2;            OneLine=zeros(1,N);            for k=0:1:N-1,                 Evec=exp(-i*2*pi*k*m*alpha);                 OneLine(1,k+1)=Evec*Xvec;            end;            Y(n+1,:)=Y(n+1,:)+OneLine*Factor;        end;    end;    for k=0:1:N-1,        for l=-N:N-1,            Factor=exp(i*k*pi*l/N);            m=-N/2+1:N/2;            Xvec=X(N+1:1:2*N,l+N+1);            alpha=-l/N^2;            OneCol=zeros(N,1);            for n=0:1:N-1,                Evec=exp(-i*2*pi*n*m*alpha);                OneCol(n+1,1)=Evec*Xvec;            end;            Y(:,k+1)=Y(:,k+1)+OneCol*Factor;        end;    end;    elseif Method==4, % speeding by replacing the inner (M-wise) sum by FRFFT        Y=zeros(N,N);    for n=0:1:N-1,        for l=-N:N-1,                           Factor=exp(i*n*pi*l/N);            Xvec=X(N:-1:1,l+N+1);            alpha=-l/N^2;            OneLine=My_FRFT(Xvec,alpha);            OneLine=(OneLine.').*exp(-i*pi*l*(0:1:N-1)/N);            Y(n+1,:)=Y(n+1,:)+OneLine*Factor;        end;    end;    for k=0:1:N-1,        for l=-N:N-1,            Factor=exp(i*k*pi*l/N);            Xvec=X(2*N:-1:N+1,l+N+1);            alpha=l/N^2;            OneCol=My_FRFT(Xvec,alpha);            OneCol=OneCol.*(exp(i*pi*l*(0:1:N-1)/N).');            Y(:,k+1)=Y(:,k+1)+OneCol*Factor;        end;    end;    elseif Method==5, % speeding by preparing to replace the outer (L-wise) sum - step 1        Y=zeros(N,N);    for l=-N:N-1,                       Xvec=X(N:-1:1,l+N+1);        alpha=-l/N^2;        OneLine=My_FRFT(Xvec,alpha);        OneLine=(OneLine.').*exp(-i*pi*l*(0:1:N-1)/N);        for n=0:1:N-1,            Factor=exp(i*n*pi*l/N);            Y(n+1,:)=Y(n+1,:)+OneLine*Factor;        end;    end;    for l=-N:N-1,        Xvec=X(2*N:-1:N+1,l+N+1);        alpha=l/N^2;        OneCol=My_FRFT(Xvec,alpha);        OneCol=OneCol.*(exp(i*pi*l*(0:1:N-1)/N).');        for k=0:1:N-1,            Factor=exp(i*k*pi*l/N);            Y(:,k+1)=Y(:,k+1)+OneCol*Factor;        end;    end;    elseif Method==6, % speeding by preparing to replace the outer (L-wise) sum - step 2        Y=zeros(N,N);    Temp1=zeros(N,2*N);    for l=-N:N-1,                       Xvec=X(N:-1:1,l+N+1);        alpha=-l/N^2;        OneLine=My_FRFT(Xvec,alpha);        OneLine=(OneLine.').*exp(-i*pi*l*(0:1:N-1)/N);        Temp1(:,l+N+1)=OneLine.';    end;    for n=0:1:N-1,        for l=-N:N-1,                           Factor=exp(i*n*pi*l/N);            Y(n+1,:)=Y(n+1,:)+Temp1(:,l+N+1).'*Factor;        end;    end;        Temp2=zeros(N,2*N);    for l=-N:N-1,        Xvec=X(2*N:-1:N+1,l+N+1);        alpha=l/N^2;        OneCol=My_FRFT(Xvec,alpha);        OneCol=OneCol.*(exp(i*pi*l*(0:1:N-1)/N).');        Temp2(:,l+N+1)=OneCol;    end;    for k=0:1:N-1,        for l=-N:1:N-1,            Factor=exp(i*k*pi*l/N);            Y(:,k+1)=Y(:,k+1)+Temp2(:,l+N+1)*Factor;        end;    end;           elseif Method==7, % speeding by replacing the outer (L-wise) sum        Y=zeros(N,N);    Temp1=zeros(N,2*N);    for l=-N:N-1,                       Xvec=X(N:-1:1,l+N+1);        alpha=-l/N^2;        OneLine=My_FRFT(Xvec,alpha);        OneLine=(OneLine.').*exp(-i*pi*l*(0:1:N-1)/N);        Temp1(:,l+N+1)=OneLine.';    end;    for k=1:1:N,            Temp_vec=2*N*ifft(Temp1(k,:)).*(-1).^(0:2*N-1);        Y(:,k)=Temp_vec(1:N).';    end;    Temp2=zeros(N,2*N);    for l=-N:N-1,        Xvec=X(2*N:-1:N+1,l+N+1);        alpha=l/N^2;        OneCol=My_FRFT(Xvec,alpha);        OneCol=OneCol.*(exp(i*pi*l*(0:1:N-1)/N).');        Temp2(:,l+N+1)=OneCol;    end;    for k=1:1:N,            Temp_vec=2*N*ifft(Temp2(k,:)).*(-1).^(0:2*N-1);        Y(k,:)=Y(k,:)+Temp_vec(1:N);    end;    elseif Method==8, % Final algorithm - fastest and reliable        Y=zeros(N,N);    Temp1=zeros(N,2*N);    for l=-N:N-1,                       Xvec=X(N:-1:1,l+N+1);        alpha=-l/N^2;        OneLine=My_FRFT(Xvec,alpha);        OneLine=(OneLine.').*exp(-i*pi*l*(0:1:N-1)/N);        Temp1(:,l+N+1)=OneLine.';    end;    Temp_Array=2*N*ifft(Temp1,[],2);    Temp_Array=Temp_Array(:,1:N)*diag((-1).^(0:N-1));    Y=Temp_Array.';    Temp2=zeros(N,2*N);    for l=-N:N-1,        Xvec=X(2*N:-1:N+1,l+N+1);        alpha=l/N^2;        OneCol=My_FRFT(Xvec,alpha);        OneCol=OneCol.*(exp(i*pi*l*(0:1:N-1)/N).');        Temp2(:,l+N+1)=OneCol;    end;    Temp_Array=2*N*ifft(Temp2,[],2);    Y=Y+Temp_Array(:,1:N)*diag((-1).^(0:N-1));    end;Y=Y.';return;