function F = AFTUSF_NGP_1(f,Wx,Wy,OS)%====================================================================% AFTUSF_NGP: Approximate Fourier Transform at Unequally Spaced Frequencies. % The trigonometric polynomial %            F(omegax,omegay) = sum f(i,j) exp( -i (wx*x + wy*y))% is approximated for all the frequencies in (Wx,Wy) - any grid setup. The values of % this destination grid must be in the range [0,2pi]%  % Synopsis:    F = AFTUSF_NGP(f,Wx,Wy,OS)%  % Inputs:       f		 n*n array%	                 Wx		array of x-coordinates of frequencies%	                 Wy		array of y-coordinates of frequencies%	                 OS		Oversampling factor (dyadic, >= 1). Default 4.%%  Outputs:   F        Approximate Fourier Transform at frequencies in (Wx,Wy)%		                       Array conforming to shape of Wx.%  %  Example1 - The effect of oversampling oin the accuracy for Polar coordinates% %       Nr=16; Nt=32; %       [XP,YP]=Create_Grid('P',[Nr,Nt,pi],''); %       In=zeros(16,16); In(4:14,7:11)=1;%       Out1=Brute_Force_Transform(In,XP,YP);%       for OS=1:1:16, %           Out3=AFTUSF_NGP_1(In,XP,YP,OS); %           disp([OS,mean(mean(abs(Out1-Out3)))]);%           figure(1); clf; %           [Wx,Wy]=Create_Grid('C',[16*OS,16*OS,-pi,pi,-pi,pi],'go'); hold on;%           plot(XP,YP,'r.'); %           pause;%       end;%       xlabel('Red - destination grid, Green - computed grid');%% Example 2 - how dense cartezian grid is approx. by a sparser cartezian grid%       %       [Wxx,Wyy] = Create_Grid('C',[64,64,-pi,pi,-pi,pi],''); % destination grid% 	    f   = zeros(4,4); f(1,2) = 1; % given 4*4 signal% 	    Ff = Brute_Force_Transform(f,Wxx,Wyy);%       for OS=1:1:16,% 	         F = AFTUSF_NGP_1(f,Wxx,Wyy,OS);% 	         D = F - Ff;%            figure(1); clf;% 	         [Wx,Wy]=Create_Grid('C',[4*OS,4*OS,-pi,pi,-pi,pi],'.r');%            hold on; plot(Wxx,Wyy,'g*');% 	         disp([OS,mean(mean(abs(D)))]); %            xlabel('Red - destination grid, Green - computed grid');%            pause;%       end;%% Written by Dave Donoho, and rearranged with slight changes by Miki Elad % on March 20th, 2005.% % Copyright (c) David Donoho 2000%====================================================================if nargin < 3, OS = 4; end;n   = size(f,1); 					% assumes f squareN   = n*OS;Ef  = EmbedInZeros(f,N,'corner');	% pads f out to extension by factor OSF1 = fft2(Ef);						% Value of F%F = EvalNGPAve(F1,Wx,Wy);return;%===================================================function I = EmbedInZeros(x,N,where)%---------------------------------------------------------------------------------------------% EmbedInZeros: Embed an array in a sea of zeros. A copy of the array x is % embedded into an n*n part of a larger N*N array I.  The additional elements % are taken to be zero. The position of the window is either the central part, % an n*n window near N/2, or an n*n window bounded by (1,1) -> (n,n). %  % Synopsis: I = EmbedInZeros(x,N,where)%  % Inputs:    x		      array(n,n); n < N, data to embed%	               N		    integer; size of array into which to embed%	               where	string; 'center' / 'corner'%  Outputs: I	         array(N,N)%% Copyright (c) David Donoho 2000%---------------------------------------------------------------------------------------------if nargin < 3,    where = 'center';end%n = size(x,1);I = zeros(N);switch where,case 'center',    lo = floor(N/2) - (floor(n/2)-1);    hi = lo + n -1;case 'corner',    lo = 1;    hi = n;endI(lo:hi,lo:hi) = x; %===================================================function Y = EvalNGPAve(F,xPoints,yPoints)%---------------------------------------------------------------------------------------------% EvalNGP: Evaluate Nearest Grid Point Averages at Scattered Points. % At each point of an N*N grid the values of a function are given by the array F. % The grid points are assumed to be at points (2*pi*(k1-1)/N,2*pi*(k2-1)/N). % The function is assumed to be 2-pi periodic in each variable. A set of points for % evaluation is given by (xPoints,yPoints)%  % Synopsis: Y = EvalNGPAve(F,xPoints,yPoints)%% Inputs:     F		       N*N array of Grid Values	%	                xPoints	x coordinates of Points to find NN%	                yPoints y coordinates of Points to find NN%% Outputs:  Y		Value of NN at specified Points %	% Copyright (c) David Donoho 2000%---------------------------------------------------------------------------------------------Npts = prod(size(xPoints));N = size(F,1);Y = zeros(size(xPoints));xPoints = (xPoints>=0).*xPoints+(xPoints<0).*(xPoints+2*pi);yPoints = (yPoints>=0).*yPoints+(yPoints<0).*(yPoints+2*pi);x = xPoints*(N/(2*pi));y = yPoints.*(N/(2*pi));    for pt = 1:Npts,    [k2,k1,u2,u1] = FindCell(x(pt),y(pt),N);  % note k1 <--> k2 swap, u2 <--> u1 swap    if k1 < N & k2 < N,        g = F(k1:(k1+1),k2:(k2+1));    elseif k1 < N,  	% Periodization        bot = k2; top = k2+1;        if bot > N, bot = bot-N; end        if top > N, top = top-N; end        g = F(k1:(k1+1),[bot top]);    elseif k2 < N,        bot = k1; top = k1+1;        if bot > N, bot = bot-N; end        if top > N, top = top-N; end        g = F([bot top],k2:(k2+1));    else        xbot = k1; xtop = k1+1;        if xbot > N, xbot = xbot-N; end        if xtop > N, xtop = xtop-N; end        ybot = k2; ytop = k2+1;        if ybot > N, ybot = ybot-N; end        if ytop > N, ytop = ytop-N; end        g = F([xbot xtop],[ybot ytop]);    end		    Y(pt) = WeightNGPAve(g,u1,u2);end%===================================================function [k1,k2,u1,u2] = FindCell(x,y,n)%---------------------------------------------------------------------------------------------% FindCell: Locate Cell Index Corresponding to given (x,y) - An n*n array of unit % square cells, with lower left corner at (0,0) is assumed.  The index of the cell% containing (x,y) is returned, where the lower left cell is indexed by (1,1)%  % Synopsis: [k1,k2] = FindCell(x,y,n)%%  Inputs: 	  x	  	  x coordinate	%	                y		y coordinate%	                n		integer; size of n*n grid%  Outputs:  k1		integer x-index of cell in grid%	                k2		integer y-index of cell in grid%	                u1		fractional x-coordinate inside cell%	                u2		fractional y-coordinate inside cell%  %	Copyright (c) David Donoho 2000%---------------------------------------------------------------------------------------------k1 = 1 + floor(x);k2 = 1 + floor(y);u1 = x - floor(x);u2 = y - floor(y);%===================================================function av = WeightNGPAve(g,u1,u2)%---------------------------------------------------------------------------------------------% WeightNGPAve: Weighted Average of Nearest Grid Points - A point (u1,u2) % obeying 0 <= u1,u2 <= 1 is given, and the values of a function g at the four % nearest lattice points (0,0),(0,1),(1,0),(1,1). A weighted average is taken of % these values, which exactly reproduces linear functions.%% Synopsis    av = WeightNGPAve(g,u1,u2)%  % Inputs: 	  g		   2*2 array%	                u1		x1-cooordinate%	                u2		x2-coordinate%  Outputs: av  	Weighted average of four values in g%% Copyright (c) David Donoho 2000%---------------------------------------------------------------------------------------------av=(1-u1)*(1-u2)*g(1,1)+(1-u1)*u2*g(1,2)+u1 *(1-u2)*g(2,1)+u1 *u2*g(2,2);