function [GridX,GridY]=Create_Oversampled_Grid(Kind,Param,Show)%====================================================================% This function creates the 'D', 'S' and the 'X' grids such that they are% oversampled. This program is similar to "Creat_Grid" but uses a different% parametrization in line with the idea of oversampling. %% Synopsis: [GridX,GridY]=Create_Grid(Kind,Param,Show)%% Input: %    Kind -  'D' for Donoho and Averbuch Recto-Polar grid, 'S'  for variation on 'D'%               Recto-Polar that has uniform angle sampling, and 'X' for the Polar grid that %               is obtained from the 'S' Recto-Polar by a uniform steps along all rays.%    Param - A set of parameters dictating the grid size and coverage%                  [N,range,OS1,OS2] - 2*OS1*N values along each ray and 2*OS2*N rays. %    Show - if non-empty, show a graph of the grid points. Show is used as the %                 plot string%% Output:%    GridX,GridY - two 2D arrays containing the grid points%% Example:%       figure(1); clf; %       [Xp1,Yp1]=Create_Oversampled_Grid('D',[8,pi,2,2],'+r'); hold on;%       [Xp2,Yp2]=Create_Oversampled_Grid('D',[16,pi,1,1],'ob'); %%       figure(1); clf; %       [Xp1,Yp1]=Create_Oversampled_Grid('S',[8,pi,2,2],'+r'); hold on;%       [Xp2,Yp2]=Create_Oversampled_Grid('S',[16,pi,1,1],'ob'); % %       figure(1); clf; %       [Xp1,Yp1]=Create_Oversampled_Grid('X',[8,pi,2,5],'+r'); hold on;%       [Xp2,Yp2]=Create_Oversampled_Grid('X',[8,pi,2,2],'ob'); %% Written by Miki Elad on Mrch 20th 2005, based on programs written by Dave Donoho.%====================================================================switch Kind  case 'D', % Recto-Polar by Donoho and Averbuch        N=Param(1);    MaxRadius=Param(2);    OS1=Param(3);    OS2=Param(4);        VX=zeros(2*N*OS1,N*OS2);    VY=zeros(2*N*OS1,N*OS2);    ll=-N*OS1:1:N*OS1-1;    theta_y=pi*ll/(N*OS1);    m=-N*OS2/2:1:N*OS2/2-1;    for k=1:1:length(theta_y),        theta_x=2*m*theta_y(k)/(N*OS2);            VX(k,:)=theta_x;        VY(k,:)=theta_y(k);    end;        HX=zeros(2*N*OS1,N*OS2);    HY=zeros(2*N*OS1,N*OS2);    ll=-N*OS1:1:N*OS1-1;    theta_x=pi*ll/(N*OS1);    m=-N*OS2/2+1:1:N*OS2/2;    for k=1:1:length(theta_x),        theta_y=2*m*theta_x(k)/(N*OS2);            HX(k,:)=theta_x(k);        HY(k,:)=theta_y;    end;        GridX=[fliplr(VX),HX]; % we have to flip in order to get a smoothly rotating rays    GridY=[fliplr(VY),HY];        GridX=GridX*MaxRadius/pi;    GridY=GridY*MaxRadius/pi;        if Show, % display the grid        plot(GridX,GridY,Show);        axis equal;        axis([-MaxRadius MaxRadius -MaxRadius MaxRadius]);    end;case 'S', % Changing the recto-polar to have uniform angle sampling        N=Param(1);    MaxRadius=Param(2);    OS1=Param(3);    OS2=Param(4);        VX=zeros(2*N*OS1,N*OS2);    VY=zeros(2*N*OS1,N*OS2);    ll=-N*OS1:1:N*OS1-1;    theta_y=pi*ll/(N*OS1);    m=-N*OS2/2:1:N*OS2/2-1;    for k=1:1:length(theta_y),        theta_x=theta_y(k)*tan(m*pi/(N*OS2)/2);            VX(k,:)=theta_x;        VY(k,:)=theta_y(k);    end;        HX=zeros(2*N*OS1,N*OS2);    HY=zeros(2*N*OS1,N*OS2);    ll=-N*OS1:1:N*OS1-1;    theta_x=pi*ll/(N*OS1);    m=-N*OS2/2+1:1:N*OS2/2;    for k=1:1:length(theta_x),        theta_y=theta_x(k)*tan(m*pi/(N*OS2)/2);            HX(k,:)=theta_x(k);        HY(k,:)=theta_y;    end;        GridX=[fliplr(VX),HX]; % we have to flip in order to get a smoothly rotating rays    GridY=[fliplr(VY),HY];        GridX=GridX*MaxRadius/pi;    GridY=GridY*MaxRadius/pi;        if Show, % display the grid        plot(GridX,GridY,Show);        axis equal;        axis([-MaxRadius MaxRadius -MaxRadius MaxRadius]);    end;case 'X', % Polar grid, generated by warping the recto-polar along angles and then rays        N=Param(1);    MaxRadius=Param(2);    OS1=Param(3);    OS2=Param(4);        VX=zeros(2*N*OS1,N*OS2);    VY=zeros(2*N*OS1,N*OS2);    ll=-N*OS1:1:N*OS1-1;    theta_y=pi*ll/(N*OS1);    m=-N*OS2/2:1:N*OS2/2-1;    for k=1:1:length(theta_y),        theta_x=theta_y(k)*tan(m*pi/(N*OS2)/2);            VX(k,:)=theta_x;        VY(k,:)=theta_y(k);    end;        HX=zeros(2*N*OS1,N*OS2);    HY=zeros(2*N*OS1,N*OS2);    ll=-N*OS1:1:N*OS1-1;    theta_x=pi*ll/(N*OS1);    m=-N*OS2/2+1:1:N*OS2/2;    for k=1:1:length(theta_x),        theta_y=theta_x(k)*tan(m*pi/(N*OS2)/2);            HX(k,:)=theta_x(k);        HY(k,:)=theta_y;    end;        GridX=[fliplr(VX),HX]; % we have to flip in order to get a smoothly rotating rays    GridY=[fliplr(VY),HY];        for k=1:1:2*N*OS1,        Factor=sqrt(GridX(k,:).^2+GridY(k,:).^2);        if min(Factor>0),             Factor=Factor./min(Factor);            GridX(k,:)=GridX(k,:)./Factor;            GridY(k,:)=GridY(k,:)./Factor;            end;    end;        if Show, % display the grid        plot(GridX,GridY,Show);        axis equal;        axis([-MaxRadius MaxRadius -MaxRadius MaxRadius]);    end;        end;return;