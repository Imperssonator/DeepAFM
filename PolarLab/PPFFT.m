function Y=PPFFT(X,S1,S2)%=====================================================================% This function performs a Recto (Pseudo) Polar transform on a 2D signal X given on a % Cartesian grid. If X is N*N, the output will have 2NS1 by 2NS2 output% values. If the input is not square, it is squared before the transform.% Also, the size is increased so as to get even number of rows and columns.%   % Synopsis: Y=PPFFT(X,S1,S2)%% Inputs -    X      N*N matrix in cartesian grid, (n is assumed to be even)   %                  S1   oversampling factor along the rays%                  S2   oversampling factor along the slopes (e.g. angles)% Outputs - Y      (2*S1*N)*(2*S2*N) matrix (theta,r)%% Example: %       This shows that the obtained transform matches the brute-force one%       N=16; X=randn(N,N); X(N/4:3*N/4,N/4:3*N/4)=1;%       [XC,YC]=Create_Oversampled_Grid('D',[N,pi,5,3],'.r');%       tic; Y_slow=Brute_Force_Transform(X,XC,YC); toc;%       tic; Y_fast=PPFFT(X,5,3); toc;%       figure(1); clf;%       subplot(2,2,1); imagesc(real(Y_fast)); xlabel('Fast - real part');%       subplot(2,2,2); imagesc(imag(Y_fast)); xlabel('Fast - imaginary part');%       subplot(2,2,3); imagesc(real(Y_slow)); xlabel('Slow - real part');%       subplot(2,2,4); imagesc(imag(Y_slow)); xlabel('Slow - imaginary part');%       disp(['Error between fast and slow: ',num2str(max(abs(Y_fast(:)-Y_slow(:))))]);% % %       This shows the relation between the PPFFT and the matrix transform %       N=16; X=randn(N,N)+sqrt(-1)*randn(N,N);%       Yf=PPFFT(X,1,1); %       [xc,yc]=Create_Oversampled_Grid('D',[N,pi,1,1],'');%       T=Transform_Matrix(N,N,xc,yc);%       Yc=T*X(:);%       plot([real(Yf)-real(reshape(Yc,[32,32]))']); % there is a transpose relation%       plot([imag(Yf)-imag(reshape(Yc,[32,32]))']); % there is a transpose relation% % Written on March 20th, 2005 by Michael Elad.%=====================================================================if nargin==1,     S1=1; S2=1;end;%------------------------------------------------------------------------------------------------------------------------------% Stage 1: Checking input size and defining the sizes of the input/output arrays%------------------------------------------------------------------------------------------------------------------------------[N1,N2]=size(X);N=ceil(max(N1,N2)/2)*2;Xnew=zeros(N,N);Xnew(N/2-floor(N1/2)+1:N/2-floor(N1/2)+N1,N/2-floor(N2/2)+1:N/2-floor(N2/2)+N2)=X;X=Xnew;Y=zeros(2*S1*N,2*S2*N); % The output array%------------------------------------------------------------------------------------------------------------------------------% Stage 2: Constructing quadrant 1 and 3%------------------------------------------------------------------------------------------------------------------------------f_tilde=fft([X; zeros((S1*2-1)*N,N)],[],1);f_tilde=fftshift(f_tilde,1); f_tilde=[f_tilde, zeros(2*S1*N,N*(S2-1))];for ll=-N*S1:1:N*S1-1,     Y(ll+N*S1+1,S2*N:-1:1)=My_FRFT_Centered(f_tilde(ll+N*S1+1,:),ll/(N^2*S1*S2)).';end;%------------------------------------------------------------------------------------------------------------------------------% Stage 3: Constructing quadrant 2 and 4%------------------------------------------------------------------------------------------------------------------------------f_tilde=fft([X, zeros(N,(S1*2-1)*N)],[],2); f_tilde=fftshift(f_tilde,2);f_tilde=f_tilde.';f_tilde=[f_tilde, zeros(2*S1*N,N*(S2-1))];for ll=-N*S1:1:N*S1-1,     Factor=exp(i*2*pi*(0:1:S2*N-1)*(N*S2/2-1)*ll/(N^2*S1*S2));     Y(ll+N*S1+1,S2*N+1:2*N*S2)=My_FRFT(f_tilde(ll+N*S1+1,:).*Factor,ll/(N^2*S1*S2)).';end;return;