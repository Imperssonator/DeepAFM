function [GridX,GridY]=Create_Grid(Kind,Param,Show)%=====================================================================% This function creates a set of points in the plane froming either Cartesian, Polar, or % Recto-Polar grids (several variations). A set of parameters dictate the span of these % points, their number, and more. %% Synopsis: [GridX,GridY]=Create_Grid(Kind,Param,Show)%% Input: %    Kind - 'C' for Cartesian, 'P' for Exact Polar, 'R' for exact Recto-Polar grid,  %               'D' for Donoho and Averbuch Recto-Polar grid, 'S'  for variation on 'D'%               Recto-Polar that has uniform angle sampling, and 'X' for the Polar grid that %               is obtained from the 'S' Recto-Polar by a uniform steps along all rays.%    Param - A set of parameters dictating the grid size and coverage%                  'C' - Param=[nx,ny,xrange,yrange] - the number of rows/columns %                          and the ranges %                  'P' - Param=[nr,nt,range] - number of circles/rays and the maximal %                          radius to use%                  'R' - Param=[nr,nt,range] - number of circles/rays and the maximal %                          radius to use%                  'S' - Param=[N,range] - 2N values along each ray and 2N rays. %                  'X' - Param=[N,range] - 2N values along each ray and 2N rays. %                  'D' - Param=[N,range] - 2N values along each ray and 2N rays. (i.e. Nt=4Nr)%    Show - if non-empty, show a graph of the grid points. Show is used as the %                 plot string%% Output:%    GridX,GridY - two 2D arrays containing the grid points%% Remark: Exact grids are grid that are pure rotational. Since Donoho-Averbuch grid %                has an even number of points along each ray, it is not exact. Thus, 'C', 'P', %               and 'R' are exact, while 'D', 'S', and 'X' are not so.% The sections on 'S' and 'X" are taken from 'Grid_Evolution.m' file.%% Examples:%       figure(1); clf; %       [XC,YC]=Create_Grid('C',[8,8,-1,1,-1,1],'+r'); hold on;%       [XP,YP]=Create_Grid('P',[8,8,1],'.b');%       [XR,YR]=Create_Grid('R',[8,8,1],'oc');%%       The following graph shows that a RectoPolar FT of 16*16 can be produced by %       3 shifted Cartesian grids of 32*32 each. %       figure(1); clf; %       [XC,YC]=Create_Grid('C',[32,32,-pi,pi,-pi,pi],'or'); hold on;%       d=pi/32;%       [XC,YC]=Create_Grid('C',[32,32,-pi+d,pi+d,-pi,pi],'og'); %       [XC,YC]=Create_Grid('C',[32,32,-pi,pi,-pi+d,pi+d],'oc'); %       [XR,YR]=Create_Grid('R',[16,16,pi],'.b');%%       The following graph shows that a RectoPolar FT of Nr and Nt parameters %       can be produced by a Cartesian grid of N*N points, where N=Nt*Nr/4%       figure(1); clf; %       Nr=8; Nt=120; N=Nr*Nt/4;%       [XR,YR]=Create_Grid('R',[Nr,Nt,pi],'+r'); hold on;%       [XC,YC]=Create_Grid('C',[N,N,-pi,pi,-pi,pi],'og'); %       [XP,YP]=Create_Grid('P',[Nr,Nt,pi],'.m'); %       Actually, after applying 1DFFT for all the rows, only 2Nr+1 columns needs to be %       computed. Similarly, after applying 1DFFT for all the columns, only 2Nr+1 rows %       needs to be computed. Thus, leading to ~Nt/4 savings over full Cartesian FFT.% %       The following shows the relation between the RectoPolar grid and the %       RectoPolar as used by Donoho and Averbuch%       figure(1); clf; %       [XC,YC]=Create_Grid('D',[4,pi],'.r');%       hold on;%       [XC,YC]=Create_Grid('R',[5,16,5/4*pi],'og');%       [XC,YC]=Create_Grid('R',[4,16,pi],'ob');% %       The following is a description of the changes from the Recto-Polar to the Polar%       figure(1); clf; %       [X1,Y1]=Create_Grid('D',[8,pi],'*g'); hold on;%       [X2,Y2]=Create_Grid('S',[8,pi],'ob');%       [X3,Y3]=Create_Grid('X',[8,pi],'.c');%% Written by Miki Elad on March 20th 2005, based on programs written by Dave Donoho.%=====================================================================switch Kindcase 'C', % Cartesian        if nargin==1,        Param=[8,8,-1,1-1,1];    end;    Nx=Param(1);    Ny=Param(2);    xrange=Param(3:4);    yrange=Param(5:6);        xpoints=xrange(1):(xrange(2)-xrange(1))/Nx:xrange(2);    xpoints=xpoints(1:end-1);    ypoints=yrange(1):(yrange(2)-yrange(1))/Ny:yrange(2);    ypoints=ypoints(1:end-1);    [GridX,GridY]=meshgrid(xpoints,ypoints);        if Show, % display the grid        plot(GridX,GridY,Show);        axis equal;        axis([xrange, yrange]);    end;    case 'P', % Polar        if nargin==1,        Param=[8,8,1];    end;    Nr=Param(1);    Nt=Param(2);    MaxRadius=Param(3);        Rpoints=0:MaxRadius/Nr:MaxRadius;    Rpoints=Rpoints(1:end-1);    Tpoints=0:2*pi/Nt:2*pi;    Tpoints=Tpoints(1:end-1);    [GridR,GridT]=meshgrid(Rpoints,Tpoints);    GridX=GridR.*cos(GridT);    GridY=GridR.*sin(GridT);        if Show, % display the grid        plot(GridX,GridY,Show);        axis equal;        axis([-MaxRadius MaxRadius -MaxRadius MaxRadius]);    end;    case 'R', % Recto-Polar        Nr=Param(1);    Nt=Param(2);    MaxRadius=Param(3);        rangeT=-1:8/Nt:1;    rangeT=rangeT(1:end-1);    HorizonD=[rangeT,ones(1,Nt/4),-rangeT,-ones(1,Nt/4)];    VerticalD=[ones(1,Nt/4),-rangeT,-ones(1,Nt/4),rangeT];    Tpoints=atan2(HorizonD,VerticalD);    GridT=Tpoints'*ones(1,Nr);    Rpoints=0:MaxRadius/Nr:MaxRadius;    Rpoints=Rpoints(1:end-1);    GridR=sqrt(HorizonD.^2+VerticalD.^2)'*Rpoints;    GridX=GridR.*cos(GridT);    GridY=GridR.*sin(GridT);        if Show, % display the grid        plot(GridX,GridY,Show);        axis equal;        axis([-MaxRadius MaxRadius -MaxRadius MaxRadius]);    end;  case 'S', % Changing the recto-polar to have uniform angle sampling        N=Param(1);    MaxRadius=Param(2);        VX=zeros(2*N,N);    VY=zeros(2*N,N);    ll=-N:1:N-1;    theta_y=pi*ll/N;    m=-N/2:1:N/2-1;    for k=1:1:length(theta_y),        theta_x=theta_y(k)*tan(m*pi/N/2);            VX(k,:)=theta_x;        VY(k,:)=theta_y(k)*ones(1,N);    end;        HX=zeros(2*N,N);    HY=zeros(2*N,N);    ll=-N:1:N-1;    theta_x=pi*ll/N;    m=-N/2+1:1:N/2;    for k=1:1:2*N,        theta_y=theta_x(k)*tan(m*pi/N/2);            HX(k,:)=theta_x(k)*ones(1,N);        HY(k,:)=theta_y;    end;        GridX=[fliplr(VX),HX]; % we have to flip in order to get a smoothly rotating rays    GridY=[fliplr(VY),HY];        GridX=GridX*MaxRadius/pi;    GridY=GridY*MaxRadius/pi;        if Show, % display the grid        plot(GridX,GridY,Show);        axis equal;        axis([-MaxRadius MaxRadius -MaxRadius MaxRadius]);    end;case 'X', % Polar grid, generated by warping the recto-polar along angles and then rays        N=Param(1);    MaxRadius=Param(2);        VX=zeros(2*N,N);    VY=zeros(2*N,N);    ll=-N:1:N-1;    theta_y=pi*ll/N;    m=-N/2:1:N/2-1;    for k=1:1:length(theta_y),        theta_x=theta_y(k)*tan(m*pi/N/2);            VX(k,:)=theta_x;        VY(k,:)=theta_y(k)*ones(1,N);    end;        HX=zeros(2*N,N);    HY=zeros(2*N,N);    ll=-N:1:N-1;    theta_x=pi*ll/N;    m=-N/2+1:1:N/2;    for k=1:1:2*N,        theta_y=theta_x(k)*tan(m*pi/N/2);            HX(k,:)=theta_x(k)*ones(1,N);        HY(k,:)=theta_y;    end;        GridX=[fliplr(VX),HX]; % we have to flip in order to get a smoothly rotating rays    GridY=[fliplr(VY),HY];        for k=1:1:2*N,        Factor=sqrt(GridX(k,:).^2+GridY(k,:).^2);        if min(Factor>0),             Factor=Factor./min(Factor);            GridX(k,:)=GridX(k,:)./Factor;            GridY(k,:)=GridY(k,:)./Factor;            end;    end;        if Show, % display the grid        plot(GridX,GridY,Show);        axis equal;        axis([-MaxRadius MaxRadius -MaxRadius MaxRadius]);    end;    case 'D', % Recto-Polar by Donoho and Averbuch        N=Param(1);    MaxRadius=Param(2);        VX=zeros(2*N,N);    VY=zeros(2*N,N);    ll=-N:1:N-1;    theta_y=pi*ll/N;    m=-N/2:1:N/2-1;    for k=1:1:length(theta_y),        theta_x=2*m*theta_y(k)/N;            VX(k,:)=theta_x;        VY(k,:)=theta_y(k)*ones(1,N);    end;        HX=zeros(2*N,N);    HY=zeros(2*N,N);    ll=-N:1:N-1;    theta_x=pi*ll/N;    m=-N/2+1:1:N/2;    for k=1:1:2*N,        theta_y=2*m*theta_x(k)/N;            HX(k,:)=theta_x(k)*ones(1,N);        HY(k,:)=theta_y;    end;        GridX=[fliplr(VX),HX]; % we have to flip in order to get a smoothly rotating rays    GridY=[fliplr(VY),HY];        GridX=GridX*MaxRadius/pi;    GridY=GridY*MaxRadius/pi;        if Show, % display the grid        plot(GridX,GridY,Show);        axis equal;        axis([-MaxRadius MaxRadius -MaxRadius MaxRadius]);    end;    end;return;